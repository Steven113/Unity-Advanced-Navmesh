//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;


namespace Assets.Scripts
{
	public class BinaryHeap<T>  where T:IComparable<T>
	{
		//public BinaryHeapNode root;
		public List<T> heap = new List<T>();

		public BinaryHeap (int projectedSize){
			heap.Capacity = projectedSize+1;
			heap.Add (default(T));//to force indexes to start at 1
		}

		public void Insert(T node){
			//heap [heap.Count] = node;
			heap.Add (node);
			if (heap.Count == 2) {
				return;
			}
			int indexOfChild = (int)((heap.Count-1));
			while (indexOfChild>1 && (heap[indexOfChild-1]==null || heap[indexOfChild/2]==null || heap[indexOfChild/2].CompareTo(heap[indexOfChild])==1)) {
				T temp = heap[indexOfChild];
				heap[indexOfChild] = heap[indexOfChild/2];
				//if (temp!=null){
				heap[indexOfChild/2] = temp;
				//} else {
					//heap.RemoveAt(indexOfChild);
				//}
				//if (indexOfChild<1){
				//	break;
				//}
				indexOfChild/=2;
			}

		}

		public bool validate(){
			bool result = true;
			for (int i = 1; i< heap.Count; i++) {
				result = result && (i*2<heap.Count?((heap[i*2].CompareTo(heap[i])==1) || (heap[i*2].CompareTo(heap[i])==0)):true) && ((i*2+1)<heap.Count?((heap[i*2+1].CompareTo(heap[i])==1)||(heap[i*2+1].CompareTo(heap[i])==0)):true);
				if (!result){
					Debug.Log("Error at "+ i + " of "+heap.Count);
					break;
				}
			}
			return result;
		}

		public void Remove(T node){
			for (int i =1; i<heap.Count && (node.CompareTo(heap[i])==-1 || (node.CompareTo(heap[i])==0)); ++i){
				if (heap[i]!=null && heap[i].Equals(node)){
					heap[i]=heap[heap.Count-1];
					heap.RemoveAt(heap.Count-1);
					delete(i);
					break;
				}
			}
		}

		public bool ContainsBetterNode(T node, int numNodesToCheck = 20){
			for (int i =1; i<heap.Count && node.CompareTo(heap[i])==-1 && i<numNodesToCheck; ++i){
				if (heap[i]!=null && heap[i].Equals(node)){
					delete(i);
					return true;
				}
			}
			return false;
		}

		void delete(int index){
			int indexOfLowestValue = index;
			if ((index * 2) < heap.Count && heap [index * 2].CompareTo(heap [indexOfLowestValue])==-1) {
				indexOfLowestValue  = index*2;
				//T temp = heap [index];
				//heap[index] = heap[index*2];
				//heap[index*2] = temp;
				//delete(index*2);
			}

			if ((index * 2+1) < heap.Count && heap [index * 2+1].CompareTo(heap [indexOfLowestValue])==-1) {
//				T temp = heap [index];
				indexOfLowestValue  = index*2+1;
//				heap[index] = heap[index*2+1];
//				heap[index*2+1] = temp;
//				delete(index*2+1);
			}
			if (indexOfLowestValue != index) {
				T temp = heap [index];
				heap [index] = heap [indexOfLowestValue];
				heap [indexOfLowestValue] = temp;
				delete (indexOfLowestValue);
			}
		}

		public void Clear(){
			heap.Clear ();
			heap.Add (default(T));//to force indexes to start at 1
		}

//		public T delete (int index,T valueToSwap){
//			T temp = heap [index];
//			throw new NotImplementedException ();
////			if ((index * 2 < heap.Count) && ((index * 2 + 1) < heap.Count) && heap [index * 2]!=null && heap [index * 2+1]!=null) {
////				if (heap [index * 2].f < heap [index * 2 + 1].f) {
////					heap [index] = delete (index * 2,heap [index]);
////				} else {
////					heap [index] = delete (index * 2 + 1,heap [index]);
////				}
////			} else if (index * 2 < heap.Count) {
////				heap [index] = delete (index * 2,heap [index]);
////			} else if ((index * 2 + 1) < heap.Count) {
////				heap [index] = delete (index * 2 + 1,heap [index]);
////			} else {
////				//if (valueToSwap!=null){
////					heap[index] = valueToSwap;
////				//} else {
////				//	heap.RemoveAt(index);
////				//}
////			}
////			if (index < heap.Count) {
////				return temp;
////			} else {
////				return null;
////			}
//		}

		public bool ContainsNode(T node){
			return heap.BinarySearch (node) >= 0;
		}

		public T RemoveMin(){
			T result = heap [1];
			int hc = heap.Count;
			heap [1] = heap[hc-1];
			heap.RemoveAt (hc - 1);

			T default_val = default(T);

			int index = 1;

			hc = heap.Count;

			//while heap property broken and has at least one child

			T rs_val = default(T);
			T ls_val = default(T);

			while (index<(hc) && (((((index*2)<hc && ((rs_val = heap[index*2]).CompareTo(heap[index]))==-1)) && ((index*2 + 1)<hc && ((ls_val = heap[index*2+1]).CompareTo(heap[index])==-1))) || ((((index*2)<hc && ((rs_val = heap[index*2]).CompareTo(heap[index]))==-1)) || ((index*2 + 1)<hc && ((ls_val = heap[index*2+1]).CompareTo(heap[index])==-1))))){
				bool has_r_child = (index*2)<hc;
				bool has_l_child = (index*2+1)<hc;

				if (has_r_child && has_l_child){
					if (rs_val.CompareTo(ls_val)==-1){
						T temp = rs_val;
						heap[index*2] = heap[index];
						heap[index] = temp;
						index*=2;
					} else {
						T temp = ls_val;
						heap[index*2 + 1] = heap[index];
						heap[index] = temp;
						index= index*2 + 1;
					}
				} else if (has_r_child){
					T temp = rs_val;
					heap[index*2] = heap[index];
					heap[index] = temp;
					index*=2;
				} else if (has_l_child){
					T temp = ls_val;
					heap[index*2 + 1] = heap[index];
					heap[index] = temp;
					index= index*2 + 1;
				} else {
					break;
				}
			}

//			int indexOfChild = (int)((heap.Count-1));
//			while (indexOfChild>1 && (heap[indexOfChild-1]==null || heap[indexOfChild/2]==null || heap[indexOfChild/2].CompareTo(heap[indexOfChild])==1)) {
//				T temp = heap[indexOfChild];
//				heap[indexOfChild] = heap[indexOfChild/2];
//				//if (temp!=null){
//				heap[indexOfChild/2] = temp;
//				//} else {
//				//heap.RemoveAt(indexOfChild);
//				//}
//				//if (indexOfChild<1){
//				//	break;
//				//}
//				indexOfChild/=2;
//			}

			return result;
		}


		public T GetMin(){
			return heap [1];
		}

		public int Count{
			get{
				return heap.Count-1;
			}
		}

//		public void DrawAll(Color col, bool showNeighbours = false){
//			for (int i= 1; i<heap.Count; ++i) {
//				if (heap[i]!=null){
//					heap[i].triangle.DrawOutline(col,showNeighbours,1f);
//				}
//			}
//		}
	}

//	public class BinaryHeapNode<T>{
//		public BinaryHeapNode leftChild = null;
//		public T value = null;
//		public BinaryHeapNode rightChild = null;
//		public int depth = 0;
//		
//		public BinaryHeapNode(T value, BinaryHeapNode lChild, BinaryHeapNode rChild, int depth=0){
//			this.value = value;
//			this.leftChild = lChild;
//			this.rightChild = rChild;
//		}
//
//		public void Insert(T node){
//			if (node.f < value.f) {
//				if (leftChild == null) {
//					leftChild = new BinaryHeapNode (node, null, null,depth+1);
//				} else {
//					leftChild.Insert (node);
//				}
//			} else {
//				if (rightChild == null) {
//					rightChild = new BinaryHeapNode (node, null, null,depth+1);
//				} else {
//					rightChild.Insert (node);
//				}
//			}
//		}
//
//
//
//	}
}

